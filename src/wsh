#!/usr/bin/env sh

# LIBRARY IMPORTS
. /var/lib/warden/utilities/auth  # used for password authentication
. /var/lib/warden/utilities/Log   # used for Logging
. /var/lib/warden/utilities/array # used to manage command array (posix compliant)

# CONFIG IMPORT
. /etc/warden/warden.conf


# LOCAL SESSION LOCK VARIABLE
SESSION_LOCK=false


# CHECK IF THE SESSION IS SSHD RELATED
# AND SET VARIABLES APPROPIATELY
if [ -z "$SSH_CONNECTION" ];
then
    SESSION_TYPE="SYS"
else
    SESSION_TYPE="REM"
	CLIENT_IP=$(printf "%s" "$SSH_CONNECTION" | awk '{print $1}')
fi

CLIENT_TTY=$(ps hotty $$)  # grabs the device name for the users terminal instance


# check if the entered argument is in the PERMITTED_COMMANDS array
# as an element. Imported from config
CommandCheck () {
	
	OLD_IFS=$IFS
	IFS=:

	for allowedCommand in $ALLOWED_COMMANDS;
	do
		if [ "$1" = "$allowedCommand" ];
		then
			IFS=$OLD_IFS
			return 0
		fi
	done

	IFS=$OLD_IFS
	return 1

}


# The breakout command to escape the 
# restricted shell
Breakout () {

    if ! $SESSION_LOCK; 
    then
        if AuthPrompt;
        then
            if [ "$SESSION_TYPE" = "REM" ];
            then
                Log "[BRKA][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Breakout session created for $USER from $CLIENT_IP on $CLIENT_TTY"
            else
                Log "[BRKA][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Breakout session created for $USER on $CLIENT_TTY"
            fi
            # Log ON SUCCESSFUL BREAKOUT
            /bin/bash
        else
            if [ "$SESSION_TYPE" = "REM" ];
            then
                Log "[LOCK][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Account locked for $USER from $CLIENT_IP on $CLIENT_TTY"
            else
                Log "[LOCK][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Account locked for $USER on $CLIENT_TTY"
            fi
            # Log ON SESSION LOCK

            SESSION_LOCK=true
        fi
    else 
        # Log ON SESSION DENIED
        printf "%s\n" "Access Denied..."
    fi

}


# The shell environment that is spawned on exec (NON POSIX LOOP)
Shell () {

    # Log session type
    if [ "$SESSION_TYPE" = "REM" ];
    then
        Log "[SESO][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session created for $USER from $CLIENT_IP on $CLIENT_TTY"
    else
        Log "[SESO][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session created for $USER on $CLIENT_TTY"
    fi

    # Prevent user from exiting through 
    # keyboard calls
    trap '' INT TERM TSTP
    set -f

    # if locks permit
    if ! checkLock $USER;
    then

        # -e and -p are not posix compliant
        # however, for the ease of use and 
        # QOL improvements, it's worth it
        cd $HOME
        while read -rep "$(pwd) $ " input
        do

            # Preliminary case check for shell
            # meta/escape characters.
            # Should only filter for dashes and alphanumerics
            case "$input" in

            "")
            ;;

            *[^a-zA-Z0-9_.\ /-]*)
                Log "[CMDB][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] $input"
                # Commands that contain any weird characters will be thrown this error
                printf '%s\n' "ERROR: Command may contain restricted characters..."
            ;;

            *)
                # Input sanitation for any strays
                input=$(printf '%s' "$input" | tr -d ';&|><$`\\'\''"')
                set -- $input # Breaks apart the command into constituent parts
                command="$1" # The first command run will have a prelim check
                shift # separates arguments and commands

                if [ "$command" = "exit" ]; # If command is exit
                then
                    # Log ON EXIT
                    Log "[SESE][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session closed for $USER on $CLIENT_TTY"

                    exit 0
                elif [ "$command" = "$BREAKOUT_COMMAND" ];
                then
                    # Log ON BREAKOUT REQUEST
                    Log "[BRKR][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session breakout requested for $USER on $CLIENT_TTY"

                    Breakout
                elif CommandCheck "$command"; # If command check passes
                then
                    # Log ON COMMAND EXEC
                    Log "[CMDA][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] $command $@"
                    

                    "$command" "$@" 2> /dev/null

                else
                    # Log ON UNAVAILABLE COMMANDS
                    Log "[CMDB][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] $command $@"

                    printf '%s\n' "$command command not available..."
                fi
            ;;
        
            esac
        done
    else
        Log "[SESE][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session denied for $USER due to lock"
    fi
    
    exit 0

}


# The shell environment that is spawned on exec (POSIX COMPLIANT LOOP)
PosixShell () {

    # Log session type
    if [ "$SESSION_TYPE" = "REM" ];
    then
        Log "[SESO][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session created for $USER from $CLIENT_IP on $CLIENT_TTY"
    else
        Log "[SESO][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session created for $USER on $CLIENT_TTY"
    fi

    # Prevent user from exiting through 
    # keyboard calls
    trap '' INT TERM TSTP
    set -f

    # if locks permit
    if ! checkLock $USER;
    then

        # -e removal of -e and -p are for posix compliance
        cd $HOME
        while printf "%s" "$(pwd) $ " && read -r  input
        do

            # Preliminary case check for shell
            # meta/escape characters.
            # Should only filter for dashes and alphanumerics
            case "$input" in

            "")
            ;;

            *[^a-zA-Z0-9_.\ /-]*)
                Log "[CMDB][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] $input"
                # Commands that contain any weird characters will be thrown this error
                printf '%s\n' "ERROR: Command may contain restricted characters..."
            ;;

            *)
                # Input sanitation for any strays
                input=$(printf '%s' "$input" | tr -d ';&|><$`\\'\''"')
                set -- $input # Breaks apart the command into constituent parts
                command="$1" # The first command run will have a prelim check
                shift # separates arguments and commands

                if [ "$command" = "exit" ]; # If command is exit
                then
                    # Log ON EXIT
                    Log "[SESE][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session closed for $USER on $CLIENT_TTY"

                    exit 0
                elif [ "$command" = "$BREAKOUT_COMMAND" ];
                then
                    # Log ON BREAKOUT REQUEST
                    Log "[BRKR][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session breakout requested for $USER on $CLIENT_TTY"

                    Breakout
                elif CommandCheck "$command"; # If command check passes
                then
                    # Log ON COMMAND EXEC
                    Log "[CMDA][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] $command $@"
                    

                    "$command" "$@" 2> /dev/null

                else
                    # Log ON UNAVAILABLE COMMANDS
                    Log "[CMDB][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] $command $@"

                    printf '%s\n' "$command command not available..."
                fi
            ;;
        
            esac
        done
    else
        Log "[SESE][$SESSION_TYPE][$(date -u +"%Y%m%d-%H:%M:%S")] Session denied for $USER due to lock"
    fi
    
    exit 0

}


# Check if the shell engine is bash compatible and
# run the compliant shell function
if [ -n "$BASH_VERSION" ];
then 
    Shell
else
    PosixShell
fi